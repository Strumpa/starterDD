# class defining an assembly model for Dragon claculations. 
# R.Guasch
# Date : 09/02/2026 [created] 

from ..MaterialProperties.material_mixture import MaterialMixture, Composition
import yaml
import numpy as np
# Note: computeSantamarinaradii imported in methods to avoid circular imports

class CartesianAssemblyModel:
    """
    Class representing an assembly / fuel bundle for DRAGON calculations.

    Minimal attributes:

    - tdt_file: path to the tdt file generated by glow for the assembly or to be generated
    - lattice_description: description of the lattice (n by m grid) containing the material description of each pin.

    Methods:

    - number_fuel_material_mixtures: method to assign a material mixture index to each "physical" property of the fuel in the assembly.
    - build_calculation_scheme: method to build the calculation scheme to treat the assembly in Dragon.
    """

    def __init__(self, name, tdt_file, geometry_description_yaml):
        self.name = name
        self.tdt_file = tdt_file
        self.parse_geometry_description(geometry_description_yaml)
        self.rod_ID_to_material_dict = None # this will be set later based on the material composition definition selected for the assembly, which can be based on rod IDs in the lattice description for example, in which case this dictionary will map rod IDs to material names for the fuel in the assembly.
        self.lattice = None # this will be a data structure representing the lattice of the assembly, which can be a 2D list of pin models corresponding to the lattice description, for example.
        self.set_uniform_temperatures(fuel_temperature=900.0, gap_temperature=600.0, coolant_temperature=600.0, moderator_temperature=600.0, structural_temperature=600.0) # default uniform temperatures for the assembly, which can be updated later based on the core description or other information provided for the assembly.

    def parse_geometry_description(self, geometry_description_yaml):
        """
        Parse the geometry description YAML file for the assembly.

        Expected YAML structure::

            ASSEMBLY_GEOMETRY:

                lattice_description: n by m grid describing the material composition of each pin
                (e.g. for a 10x10 BWR assembly, entries like ``"ROD1"``, ``"ROD5G"``, etc.)

            Convention is x-increasing, y-increasing:

                - the first row is the bottom of the lattice, ordered in x-increasing direction
                - the last row is the top of the lattice
                - the first column is the left, ordered in y-increasing direction
                - the last column is the right

                assembly_pitch: pitch of the assembly lattice
                gap_wide: width of the gap between fuel pins
                channel_box_thickness: thickness of the channel box (if any)
                corner_inner_radius_of_curvature: inner radius of curvature for corners (if any)
                Gd_rod_ids: material descriptors for Gd-bearing fuel pins
                non_fuel_rod_ids: material descriptors for water rods, guide tubes, etc.

            PIN_GEOMETRY:
                fuel_radius: radius of the fuel region
                gap_radius: radius of the gap region (if any)
                clad_radius: radius of the cladding region (if any)
                height: height of the pin
                self_shielding_option: ``"Santamarina"``, ``"user_defined"``, or ``"automatic"``
                options_dict: additional options (user-defined radii, number of radial zones, etc.)

            WATER_ROD_GEOMETRY:
                type: "circular" or "square"
                inner_radius : <value> (for circular water rods)
                outer_radius : <value> (for circular water rods)
                inner_side : <value> (for square water rods)
                outer_side : <value> (for square water rods)
                centers: [(x, y) coordinates for the centers of the water rods in the lattice, e.g. [(0.5, 0.5), (2.5, 0.5)] for two water rods centered in the middle of the first and third cells of the first row of the lattice)]
        """
        with open(geometry_description_yaml, 'r') as file:
            yaml_data = yaml.safe_load(file)

        # Validate top-level YAML sections
        self._validate_yaml_keys(yaml_data, geometry_description_yaml)

        self.lattice_description = yaml_data.get("ASSEMBLY_GEOMETRY", {}).get("lattice_description", [])
        self.assembly_pitch = yaml_data.get("ASSEMBLY_GEOMETRY", {}).get("assembly_pitch", None)
        self.gap_wide = yaml_data.get("ASSEMBLY_GEOMETRY", {}).get("gap_wide", None)
        self.channel_box_thickness = yaml_data.get("ASSEMBLY_GEOMETRY", {}).get("channel_box_thickness", None)
        self.corner_inner_radius_of_curvature = yaml_data.get("ASSEMBLY_GEOMETRY", {}).get("corner_inner_radius_of_curvature", None)
        self.Gd_rod_ids = yaml_data.get("ASSEMBLY_GEOMETRY", {}).get("Gd_rod_ids", [])
        self.non_fuel_rod_ids = yaml_data.get("ASSEMBLY_GEOMETRY", {}).get("non_fuel_rod_ids", [])
        self.geometry_type = yaml_data.get("ASSEMBLY_GEOMETRY", {}).get("lattice_type", "cartesian") # by default, assume cartesian geometry for the assembly
        self.reactor_type = yaml_data.get("ASSEMBLY_GEOMETRY", {}).get("reactor_type", "BWR") # by default, assume BWR type for the assembly, which can be used to define default self-shielding treatment strategies for the pins in the assembly based on the reactor type if no specific self-shielding option is provided for the pins in the geometry description.

        # Pincell information
        self.pin_geometry_dict = yaml_data.get("PIN_GEOMETRY", {})
        
        # Water rod / moderation box information
        self.water_rod_type = yaml_data.get("WATER_ROD_GEOMETRY", {}).get("type", None)
        if self.water_rod_type is not None and self.water_rod_type not in ["circular", "square"]:
            raise ValueError(f"Unsupported water rod geometry type: {self.water_rod_type}. Supported types are 'circular' and 'square'.")
        if self.water_rod_type == "circular": # GE14 type lattice
            self.water_rod_inner_radius = yaml_data.get("WATER_ROD_GEOMETRY", {}).get("inner_radius", None)
            self.water_rod_outer_radius = yaml_data.get("WATER_ROD_GEOMETRY", {}).get("outer_radius", None)
        elif self.water_rod_type == "square": # ATRIUM-10 type lattice
            self.water_box_inner_side = yaml_data.get("WATER_ROD_GEOMETRY", {}).get("inner_side", None)
            self.water_box_outer_side = yaml_data.get("WATER_ROD_GEOMETRY", {}).get("outer_side", None)
        self.water_rod_centers = yaml_data.get("WATER_ROD_GEOMETRY", {}).get("centers", [])
        self.number_of_water_rods = len(self.water_rod_centers)
        self.channel_box_inner_side = self.assembly_pitch - 2 * self.channel_box_thickness - 2 * self.gap_wide if self.channel_box_thickness is not None and self.gap_wide is not None else None
        n_cols = len(self.lattice_description[0]) if self.lattice_description else 0
        pin_pitch = self.pin_geometry_dict.get("pin_pitch", 0)
        self.intra_assembly_coolant_width = (self.channel_box_inner_side - n_cols * pin_pitch) / 2.0 if self.channel_box_inner_side is not None else None
        self.translation_offset = self.gap_wide + self.channel_box_thickness + self.intra_assembly_coolant_width if self.gap_wide is not None and self.channel_box_thickness is not None and self.intra_assembly_coolant_width is not None else None

    # ------------------------------------------------------------------
    # YAML key validation
    # ------------------------------------------------------------------

    # Expected keys for each top-level YAML section.
    # Keys mapped to True are required; keys mapped to False are optional.
    _EXPECTED_ASSEMBLY_KEYS = {
        "lattice_description": True,
        "assembly_pitch": True,
        "gap_wide": False,
        "channel_box_thickness": False,
        "corner_inner_radius_of_curvature": False,
        "Gd_rod_ids": False,
        "non_fuel_rod_ids": False,
        "lattice_type": False,
        "reactor_type": False,
    }

    _EXPECTED_PIN_KEYS = {
        "fuel_radius": True,
        "gap_radius": False,
        "clad_radius": False,
        "pin_pitch": True,
        "height": False,
        "self_shielding_option": False,
        "options_dict": False,
    }

    _EXPECTED_WATER_ROD_KEYS = {
        "type": True,
        "inner_radius": False,
        "outer_radius": False,
        "inner_side": False,
        "outer_side": False,
        "centers": True,
    }

    @classmethod
    def _validate_yaml_keys(cls, yaml_data, source_path="<unknown>"):
        """
        Validate the top-level and section-level keys of a geometry
        description YAML.

        * Checks that required top-level sections are present.
        * Within each section, warns about unrecognised keys (likely typos)
          and raises for missing required keys.

        Parameters
        ----------
        yaml_data : dict
            Parsed YAML data.
        source_path : str
            File path used in error messages.

        Raises
        ------
        ValueError
            If a required key is missing or an unrecognised key is found
            within a known section.
        """
        import warnings

        # --- Top-level sections ---
        known_sections = {"ASSEMBLY_GEOMETRY", "PIN_GEOMETRY", "WATER_ROD_GEOMETRY"}
        present_sections = set(yaml_data.keys()) if isinstance(yaml_data, dict) else set()
        unknown_top = present_sections - known_sections
        if unknown_top:
            warnings.warn(
                f"[YAML validation] Unrecognised top-level section(s) in "
                f"'{source_path}': {unknown_top}. "
                f"Expected sections: {known_sections}.",
                stacklevel=3,
            )

        if "ASSEMBLY_GEOMETRY" not in present_sections:
            raise ValueError(
                f"Geometry YAML '{source_path}' is missing the required "
                f"'ASSEMBLY_GEOMETRY' section."
            )

        # --- Section-level key checks ---
        section_specs = [
            ("ASSEMBLY_GEOMETRY", cls._EXPECTED_ASSEMBLY_KEYS),
            ("PIN_GEOMETRY", cls._EXPECTED_PIN_KEYS),
            ("WATER_ROD_GEOMETRY", cls._EXPECTED_WATER_ROD_KEYS),
        ]

        for section_name, expected_keys in section_specs:
            section_data = yaml_data.get(section_name, None)
            if section_data is None:
                continue
            if not isinstance(section_data, dict):
                raise ValueError(
                    f"Section '{section_name}' in '{source_path}' "
                    f"must be a mapping, got {type(section_data).__name__}."
                )

            found_keys = set(section_data.keys())
            allowed_keys = set(expected_keys.keys())
            unknown_keys = found_keys - allowed_keys

            if unknown_keys:
                raise ValueError(
                    f"[YAML validation] Unrecognised key(s) in "
                    f"'{section_name}' of '{source_path}': {unknown_keys}. "
                    f"Allowed keys: {sorted(allowed_keys)}."
                )

            missing_required = {
                k for k, required in expected_keys.items()
                if required and k not in found_keys
            }
            if missing_required:
                raise ValueError(
                    f"[YAML validation] Missing required key(s) in "
                    f"'{section_name}' of '{source_path}': {missing_required}."
                )

    def analyze_lattice_description(self, build_pins=True, apply_self_shielding=None):
        """
        Build the lattice data structure from the lattice description.

        Parameters
        ----------
        build_pins : bool
            If ``True``, create ``FuelPinModel`` / ``DummyPinModel`` objects;
            otherwise store raw descriptors.
        apply_self_shielding : str or None
            Controls radial subdivision at pin creation time:

            * ``None`` (default) – pins are created with a **single fuel zone**
              (1-region default).  A ``DragonCalculationScheme`` can later call
              ``CalculationStep.apply_radii()`` to set the desired subdivision.
            * ``"from_yaml"`` – use the ``self_shielding_option`` stored in the
              geometry YAML (backward-compatible behaviour).
            * Any other valid option string (``"Santamarina"``, ``"automatic"``,
              ``"user_defined"``) – forced for all pins.
        """
        # create a n by m grid of pin models based on the lattice description and pin geometry information provided in the geometry description yaml file, and store it in the lattice attribute of the assembly model.
        print("Analyzing lattice description and building lattice data structure with pin models based on the geometry description ...")
        print(f"Lattice description: {self.lattice_description}")
        self.lattice = []
        number_of_water_rod_placeholders = 0
        pin_pitch = self.pin_geometry_dict.get("pin_pitch", 0) if self.pin_geometry_dict else 0
        for y_index, row in enumerate(self.lattice_description):
            lattice_row = []
            for x_index, descriptor in enumerate(row):
                if self.rod_ID_to_material_dict is not None:
                    material_name = self.rod_ID_to_material_dict.get(descriptor, None)
                    rod_id = descriptor
                    print(f"Descriptor {descriptor} mapped to material name {material_name} based on rod ID to material mapping.")
                else:                    
                    material_name = descriptor # if no mapping provided, use the descriptor in the lattice description as the material name for the pin geometry definition, but this would require that the descriptors in the lattice description are directly usable as material names for the pin geometry definition, which might not be the case depending on how the material compositions are defined for the assembly.
                    rod_id = None
                    print(f"No rod ID to material mapping provided, descriptor {descriptor} will be used as a material name for the pin geometry definition.")
                pin_geometry_info = self.pin_geometry_dict # for now assume all pins have the same geometry information, but this can be updated later to allow for different pin geometries based on the material or rod ID for example by changing the structure of the pin_geometry_dict in the geometry description yaml file to allow for different geometry information for different types of pins.
                if pin_geometry_info is not None:
                    fuel_radius = pin_geometry_info.get("fuel_radius", None)
                    gap_radius = pin_geometry_info.get("gap_radius", None)
                    clad_radius = pin_geometry_info.get("clad_radius", None)
                    height = pin_geometry_info.get("height", None)

                    # Determine self-shielding option for pin creation
                    if apply_self_shielding is None:
                        # Default: 1-region, awaiting DragonCalculationScheme
                        self_shielding_option = None
                        options_dict = None
                    elif apply_self_shielding == "from_yaml":
                        # Backward compat: use whatever is in the YAML
                        self_shielding_option = pin_geometry_info.get("self_shielding_option", None)
                        options_dict = pin_geometry_info.get("options_dict", None)
                    else:
                        # Forced option for all pins
                        self_shielding_option = apply_self_shielding
                        options_dict = pin_geometry_info.get("options_dict", None)

                    if build_pins:
                        if descriptor in self.Gd_rod_ids:
                            isGd = True
                        else:     
                            isGd = False
                        if descriptor not in self.non_fuel_rod_ids:
                            pin_model = FuelPinModel(fuel_material_name=material_name, radii=[fuel_radius, gap_radius, clad_radius], height=height, isGd=isGd, self_shielding_option=self_shielding_option, options_dict=options_dict)
                            pin_model.set_rod_ID(rod_id)
                            # set the position of the pin in the lattice based on its indices in the lattice description
                            pin_model.set_position_in_lattice(x_index, y_index)
                            # compute and set the center of the pin in the assembly coordinate system
                            if self.translation_offset is not None and pin_pitch > 0:
                                center_x = self.translation_offset + x_index * pin_pitch + pin_pitch / 2.0
                                center_y = self.translation_offset + y_index * pin_pitch + pin_pitch / 2.0
                                pin_model.set_center(center_x, center_y)
                            # set the temperatures for the pin based on the uniform temperatures defined for the assembly
                            pin_model.set_fuel_temperature(self.fuel_temperature)
                            pin_model.set_clad_temperature(self.structural_temperature)
                            pin_model.set_gap_temperature(self.gap_temperature)
                            pin_model.set_coolant_temperature(self.coolant_temperature)
                            lattice_row.append(pin_model)
                        elif descriptor in self.non_fuel_rod_ids:
                            number_of_water_rod_placeholders += 1
                            dummy_pin_model = DummyPinModel(descriptor)
                            dummy_pin_model.set_position_in_lattice(x_index, y_index)
                            # compute and set the center of the dummy pin in the assembly coordinate system
                            if self.translation_offset is not None and pin_pitch > 0:
                                center_x = self.translation_offset + x_index * pin_pitch + pin_pitch / 2.0
                                center_y = self.translation_offset + y_index * pin_pitch + pin_pitch / 2.0
                                dummy_pin_model.set_center(center_x, center_y)
                            lattice_row.append(dummy_pin_model)
                    else:
                        lattice_row.append(descriptor) # if not building the pin models, just store the descriptor in the lattice data structure for now
                else:
                    lattice_row.append(descriptor) # if no specific geometry information is provided for the pin, just store the descriptor in the lattice data structure for now
            self.lattice.append(lattice_row)

        # Finalize the lattice structure after all rows have been added
        # create WaterRod depending on type and number
        # find WaterRod bounding box side length depending on number of water rods and number of placeholders
        nb_dummies_per_rod = number_of_water_rod_placeholders / self.number_of_water_rods if self.number_of_water_rods > 0 else None
        water_rod_bounding_box_side = np.sqrt(nb_dummies_per_rod) * self.pin_geometry_dict["pin_pitch"] if nb_dummies_per_rod is not None else None
        self.water_rods = []
        if water_rod_bounding_box_side is not None:
            for rod_nb in range(self.number_of_water_rods):
                center = self.water_rod_centers[rod_nb]
                if self.water_rod_type == "circular":
                    water_rod_model = CircularWaterRodModel(bounding_box_side_length=water_rod_bounding_box_side, 
                                                            inner_radius=self.water_rod_inner_radius, outer_radius=self.water_rod_outer_radius, 
                                                            center=center, rod_ID=f"WaterRod_{rod_nb+1}")
                elif self.water_rod_type == "square":
                    water_rod_model = SquareWaterRodModel(inner_side=self.water_box_inner_side, outer_side=self.water_box_outer_side, center=center, rod_ID=f"WaterRod_{rod_nb+1}")
                else:
                    raise ValueError(f"Unsupported water rod geometry type: {self.water_rod_type}. Supported types are 'circular' and 'square'.")
                water_rod_model.set_materials("MODERATOR", "CLAD", "COOLANT")
                self.water_rods.append(water_rod_model)

    def add_pin_to_lattice(self, pin_model):
        """
        add a pin model to the lattice based on its position defined by its x and y indices in the lattice description of the assembly model.
        """
        x_index = pin_model.x_index
        y_index = pin_model.y_index
        # add the pin model to the lattice at the corresponding position
        self.lattice[x_index][y_index] = pin_model

    def set_material_compositions(self, compositions):
        """
        Set the list of Composition objects for the assembly, typically parsed from a material compositions YAML file
        using parse_all_compositions_from_yaml. This must be called before number_fuel_material_mixtures so that
        each created MaterialMixture can be associated with the correct isotopic composition.

        :param compositions (list[Composition]): List of Composition objects for the materials in the assembly.
        """
        self.compositions = compositions
        # Build a lookup dict: material_name -> Composition
        self.composition_lookup = {comp.material_name: comp for comp in compositions}

    def number_fuel_material_mixtures_by_material(self):
        """
        Assign a material mixture index to each fuel self-shielding zone in the assembly based on a given
        numbering strategy. Also creates MaterialMixture objects with their associated Composition and assigns
        them back to the pins.

        Strategies:
            - "by_material": pins sharing the same fuel_material_name are grouped together.
              A unique material mixture index and name is created for each self-shielding zone
              of each distinct fuel material (e.g. UOX16_zone_1, UOX16_zone_2, ...).
            - "by_pin": (not yet implemented) each pin gets its own set of mixture indices.
            - "custom": (not yet implemented) user supplies a mapping.

        Prerequisites:
            - The lattice must have been built (analyze_lattice_description called with build_pins=True).
            - set_material_compositions must have been called so that Composition objects are available.
        """

        if not hasattr(self, 'composition_lookup') or self.composition_lookup is None:
            raise RuntimeError(
                "Material compositions have not been set. "
                "Call set_material_compositions(compositions) before numbering fuel material mixtures."
            )

        
        # ------------------------------------------------------------------
        # Step 1: Identify unique fuel materials (preserving lattice order)
        #         and record the number of self-shielding zones per material.
        # ------------------------------------------------------------------
        materials_iterated_through = []
        material_to_zone_count = {}

        for row in self.lattice:
            for pin in row:
                if isinstance(pin, FuelPinModel) and pin.fuel_material_name not in materials_iterated_through:
                    materials_iterated_through.append(pin.fuel_material_name)
                    pin.count_number_of_fuel_radial_self_shielding_zones()
                    material_to_zone_count[pin.fuel_material_name] = pin.number_of_self_shielding_fuel_zones

        # ------------------------------------------------------------------
        # Step 2: Build ordered unique material mixture names and assign
        #         sequential indices starting from 1 (DRAGON convention).
        # ------------------------------------------------------------------
        unique_material_mixture_names = []
        for material_name in materials_iterated_through:
            n_zones = material_to_zone_count[material_name]
            for zone_number in range(1, n_zones + 1):
                unique_material_mixture_names.append(f"{material_name}_zone_{zone_number}")

        material_mixtures_dict = {}
        for index, name in enumerate(unique_material_mixture_names):
            material_mixtures_dict[name] = index + 1  # mixture indices start from 1 in DRAGON

        self.material_mixtures_dict = material_mixtures_dict
        self.fuel_material_mixture_names = list(unique_material_mixture_names)
        self.fuel_material_mixture_indices = list(material_mixtures_dict.values())

        # ------------------------------------------------------------------
        # Step 3: Create MaterialMixture objects for each unique name,
        #         associating the Composition from the loaded YAML data.
        # ------------------------------------------------------------------
        self.fuel_material_mixtures = []
        for unique_name in unique_material_mixture_names:
            # Extract the base material name (handles names with underscores)
            base_material_name = unique_name.rsplit("_zone_", 1)[0]
            mix_index = material_mixtures_dict[unique_name]

            # Look up the Composition for this base material
            print(f"Creating MaterialMixture for '{unique_name}' with base material '{base_material_name}' and mix index {mix_index}...")
            composition = self.composition_lookup.get(base_material_name, None)
            if composition is None:
                raise ValueError(
                    f"No Composition found for fuel material '{base_material_name}'. "
                    f"Ensure the material compositions YAML contains an entry with name='{base_material_name}'."
                )

            # Get fuel temperature from any pin with this material
            temperature = self._get_fuel_temperature_for_material(base_material_name)
            print(temperature)
            depletable = getattr(composition, 'depletable', False)

            mix = MaterialMixture(
                material_name=base_material_name,
                material_mixture_index=mix_index,
                composition=composition,
                temperature=temperature,
                isdepletable=depletable,
            )
            mix.set_unique_material_mixture_name(unique_name)
            self.fuel_material_mixtures.append(mix)

        # ------------------------------------------------------------------
        # Step 4: Assign the created MaterialMixture objects back to each
        #         FuelPinModel in the lattice so pins know their zone
        #         indices and names.
        # ------------------------------------------------------------------
        for row in self.lattice:
            for pin in row:
                if isinstance(pin, FuelPinModel):
                    pin.count_number_of_fuel_radial_self_shielding_zones()
                    n_zones = pin.number_of_self_shielding_fuel_zones
                    pin_mixtures = []
                    pin_mixture_indices = []
                    pin_mixture_names = []
                    for zone_number in range(1, n_zones + 1):
                        zone_name = f"{pin.fuel_material_name}_zone_{zone_number}"
                        mix_index = material_mixtures_dict[zone_name]
                        # Locate the corresponding MaterialMixture object
                        mix = next(
                            m for m in self.fuel_material_mixtures
                            if m.unique_material_mixture_name == zone_name
                        )
                        pin_mixtures.append(mix)
                        pin_mixture_indices.append(mix_index)
                        pin_mixture_names.append(zone_name)
                    pin.fuel_material_mixtures = pin_mixtures
                    pin.fuel_material_mixture_indices = pin_mixture_indices
                    pin.fuel_material_mixture_names = pin_mixture_names

        print(f"[by_material] Created {len(self.fuel_material_mixtures)} fuel material mixtures "
                f"for {len(materials_iterated_through)} unique fuel materials.")

    def check_diagonal_symmetry(self):
        """
        Check whether the lattice description has any diagonal symmetry.

        Checks anti-diagonal symmetry first (axis from top-left to bottom-right
        in physical space), then main-diagonal (transpose) symmetry.

        Returns
        -------
        str or None
            ``"anti-diagonal"`` if ``lattice[i][j] == lattice[n-1-j][n-1-i]``,
            ``"main-diagonal"`` if ``lattice[i][j] == lattice[j][i]``,
            ``None`` if no diagonal symmetry is found.
            If both symmetries hold, ``"anti-diagonal"`` is returned
            (priority for physical BWR convention).
        """
        if self.check_anti_diagonal_symmetry():
            return "anti-diagonal"
        if self.check_main_diagonal_symmetry():
            return "main-diagonal"
        return None

    def check_anti_diagonal_symmetry(self):
        """
        Check whether the lattice description is symmetric about the
        anti-diagonal, i.e. the axis joining (x_min, y_max) (top-left) to
        (x_max, y_min) (bottom-right) in physical space.

        Matrix condition: ``lattice[i][j] == lattice[n-1-j][n-1-i]``.

        Returns
        -------
        bool
        """
        n = len(self.lattice_description)
        for row in self.lattice_description:
            if len(row) != n:
                return False
        for i in range(n):
            for j in range(n):
                if self.lattice_description[i][j] != self.lattice_description[n - 1 - j][n - 1 - i]:
                    return False
        return True

    def check_main_diagonal_symmetry(self):
        """
        Check whether the lattice description is symmetric about its main
        diagonal (transpose symmetry).

        Matrix condition: ``lattice[i][j] == lattice[j][i]``.

        Returns
        -------
        bool
        """
        n = len(self.lattice_description)
        for row in self.lattice_description:
            if len(row) != n:
                return False
        for i in range(n):
            for j in range(i + 1, n):
                if self.lattice_description[i][j] != self.lattice_description[j][i]:
                    return False
        return True

    def number_fuel_material_mixtures_by_pin(self):
        """
        Assign a unique set of material mixture indices to every self-shielding
        zone in every fuel pin, so that each pin can be depleted independently.

        Naming convention::

            <material_composition>_zone<zone_idx>_pin<pin_idx>

        If the lattice has diagonal symmetry (anti-diagonal or main-diagonal),
        pins at mirrored positions share the same ``pin_idx`` (and therefore
        the same material mixture objects), reducing the number of unique
        mixtures.

        The symmetry detection is done automatically by
        ``check_diagonal_symmetry()``, which checks anti-diagonal first
        (the standard BWR convention), then main-diagonal.

        Prerequisites
        -------------
        * ``analyze_lattice_description(build_pins=True)`` must have been called.
        * ``set_material_compositions(compositions)`` must have been called.
        """
        if not hasattr(self, 'composition_lookup') or self.composition_lookup is None:
            raise RuntimeError(
                "Material compositions have not been set. "
                "Call set_material_compositions(compositions) before numbering fuel material mixtures."
            )

        # ------------------------------------------------------------------
        # Step 1: Detect diagonal symmetry
        # ------------------------------------------------------------------
        symmetry_type = self.check_diagonal_symmetry()  # "anti-diagonal", "main-diagonal", or None
        self.lattice_has_diagonal_symmetry = symmetry_type

        # ------------------------------------------------------------------
        # Step 2: Assign a pin_idx to every fuel-pin position.
        #         Symmetric partners share the same pin_idx.
        # ------------------------------------------------------------------
        pin_idx_counter = 0
        position_to_pin_idx = {}  # (row, col) → pin_idx

        n_rows = len(self.lattice)
        for i in range(n_rows):
            for j in range(len(self.lattice[i])):
                pin = self.lattice[i][j]
                if isinstance(pin, FuelPinModel) and (i, j) not in position_to_pin_idx:
                    pin_idx_counter += 1
                    position_to_pin_idx[(i, j)] = pin_idx_counter
                    # If symmetric, mirror partner gets same idx
                    if symmetry_type is not None:
                        if symmetry_type == "anti-diagonal":
                            mirror = (n_rows - 1 - j, n_rows - 1 - i)
                        else:  # "main-diagonal"
                            mirror = (j, i)
                        if mirror != (i, j) and mirror not in position_to_pin_idx:
                            mirror_pin = self.lattice[mirror[0]][mirror[1]]
                            if isinstance(mirror_pin, FuelPinModel):
                                position_to_pin_idx[mirror] = pin_idx_counter

        # ------------------------------------------------------------------
        # Step 3: Build ordered unique material mixture names.
        #         Traverse the lattice row by row; for each *new* (material,
        #         pin_idx) pair, emit zone entries.
        # ------------------------------------------------------------------
        unique_material_mixture_names = []
        seen_combos = set()  # (material_name, pin_idx)

        for i in range(n_rows):
            for j in range(len(self.lattice[i])):
                pin = self.lattice[i][j]
                if isinstance(pin, FuelPinModel):
                    pin_idx = position_to_pin_idx[(i, j)]
                    combo = (pin.fuel_material_name, pin_idx)
                    if combo not in seen_combos:
                        seen_combos.add(combo)
                        pin.count_number_of_fuel_radial_self_shielding_zones()
                        n_zones = pin.number_of_self_shielding_fuel_zones
                        for zone_number in range(1, n_zones + 1):
                            unique_material_mixture_names.append(
                                f"{pin.fuel_material_name}_zone{zone_number}_pin{pin_idx}"
                            )

        # Sequential indices starting from 1
        material_mixtures_dict = {
            name: idx + 1 for idx, name in enumerate(unique_material_mixture_names)
        }

        self.material_mixtures_dict = material_mixtures_dict
        self.fuel_material_mixture_names = list(unique_material_mixture_names)
        self.fuel_material_mixture_indices = list(material_mixtures_dict.values())

        # ------------------------------------------------------------------
        # Step 4: Create MaterialMixture objects
        # ------------------------------------------------------------------
        self.fuel_material_mixtures = []
        for unique_name in unique_material_mixture_names:
            # Extract base material name from "<material>_zone<N>_pin<M>"
            base_material_name = unique_name.rsplit("_zone", 1)[0]
            mix_index = material_mixtures_dict[unique_name]

            composition = self.composition_lookup.get(base_material_name, None)
            if composition is None:
                raise ValueError(
                    f"No Composition found for fuel material '{base_material_name}'. "
                    f"Ensure the material compositions YAML contains an entry with name='{base_material_name}'."
                )

            temperature = self._get_fuel_temperature_for_material(base_material_name)
            depletable = getattr(composition, 'depletable', False)

            mix = MaterialMixture(
                material_name=base_material_name,
                material_mixture_index=mix_index,
                composition=composition,
                temperature=temperature,
                isdepletable=depletable,
            )
            mix.set_unique_material_mixture_name(unique_name)
            self.fuel_material_mixtures.append(mix)

        # ------------------------------------------------------------------
        # Step 5: Assign to each FuelPinModel
        # ------------------------------------------------------------------
        for i in range(n_rows):
            for j in range(len(self.lattice[i])):
                pin = self.lattice[i][j]
                if isinstance(pin, FuelPinModel):
                    pin_idx = position_to_pin_idx[(i, j)]
                    pin.pin_idx = pin_idx
                    pin.count_number_of_fuel_radial_self_shielding_zones()
                    n_zones = pin.number_of_self_shielding_fuel_zones
                    pin_mixtures = []
                    pin_mixture_indices = []
                    pin_mixture_names = []
                    for zone_number in range(1, n_zones + 1):
                        zone_name = f"{pin.fuel_material_name}_zone{zone_number}_pin{pin_idx}"
                        mix_index = material_mixtures_dict[zone_name]
                        mix = next(
                            m for m in self.fuel_material_mixtures
                            if m.unique_material_mixture_name == zone_name
                        )
                        pin_mixtures.append(mix)
                        pin_mixture_indices.append(mix_index)
                        pin_mixture_names.append(zone_name)
                    pin.fuel_material_mixtures = pin_mixtures
                    pin.fuel_material_mixture_indices = pin_mixture_indices
                    pin.fuel_material_mixture_names = pin_mixture_names

        n_unique_pins = pin_idx_counter
        print(f"[by_pin] Diagonal symmetry detected: {symmetry_type}")
        print(f"[by_pin] Created {len(self.fuel_material_mixtures)} fuel material mixtures "
              f"for {n_unique_pins} unique fuel pin positions.")

    def _get_fuel_temperature_for_material(self, material_name):
        """
        Return the fuel temperature from the first FuelPinModel in the lattice that matches the given material name.
        """
        for row in self.lattice:
            for pin in row:
                if isinstance(pin, FuelPinModel) and pin.fuel_material_name == material_name:
                    return getattr(pin, 'fuel_temperature', 300.0)
        return 300.0

    def identify_generating_and_daughter_mixes(self):
        """
        Group fuel material mixtures by their base composition (material_name).

        The **first** ``MaterialMixture`` encountered for each unique
        ``material_name`` is the **generating mix** – it receives a full
        isotopic composition definition in the DRAGON5 ``LIB:`` module call.
        All subsequent mixtures with the same ``material_name`` are **daughter
        mixes** – they share the same initial composition and are defined via
        ``COMB`` duplication from their generating mix.

        This distinction is important for DRAGON5:

        * Generating mixes define the reference isotopic vector.
        * Daughter mixes are lightweight copies
          (``MIX <name> COMB <generating> 1.0``) that support zone-wise
          self-shielding and independent depletion tracking while keeping
          the library creation compact.

        The method sets on each ``MaterialMixture``:

        * ``is_generating`` (bool)
        * ``generating_mix`` (``MaterialMixture`` or ``None``)

        And stores on the assembly model:

        * ``self.generating_mixes`` -- ordered list of generating mixes
        * ``self.daughter_mixes`` -- ordered list of daughter mixes

        Prerequisites
        -------------
        * One of ``number_fuel_material_mixtures_by_material()`` or
          ``number_fuel_material_mixtures_by_pin()`` must have been called.
        """
        if not hasattr(self, 'fuel_material_mixtures') or self.fuel_material_mixtures is None:
            raise RuntimeError(
                "Fuel material mixtures have not been numbered yet. "
                "Call number_fuel_material_mixtures_by_material() or "
                "number_fuel_material_mixtures_by_pin() first."
            )

        seen_compositions = {}  # material_name → first MaterialMixture
        self.generating_mixes = []
        self.daughter_mixes = []

        for mix in self.fuel_material_mixtures:
            if mix.material_name not in seen_compositions:
                mix.is_generating = True
                mix.generating_mix = None
                seen_compositions[mix.material_name] = mix
                self.generating_mixes.append(mix)
            else:
                mix.is_generating = False
                mix.generating_mix = seen_compositions[mix.material_name]
                self.daughter_mixes.append(mix)

        print(f"[identify_mixes] Found {len(self.generating_mixes)} generating mixes "
              f"and {len(self.daughter_mixes)} daughter mixes.")

    def get_fuel_material_mixture_names(self):
        """
        Return the list of unique fuel material mixture names created by number_fuel_material_mixtures.
        These names can be used for zone assignment in the geometry (e.g. GLOW PropertyType.MATERIAL).
        """
        if not hasattr(self, 'fuel_material_mixture_names'):
            raise RuntimeError("Fuel material mixtures have not been numbered yet. Call number_fuel_material_mixtures first.")
        return self.fuel_material_mixture_names

    def get_fuel_material_mixture_indices(self):
        """
        Return the list of unique fuel material mixture indices created by number_fuel_material_mixtures.
        These indices correspond 1-to-1 to the names returned by get_fuel_material_mixture_names.
        """
        if not hasattr(self, 'fuel_material_mixture_indices'):
            raise RuntimeError("Fuel material mixtures have not been numbered yet. Call number_fuel_material_mixtures first.")
        return self.fuel_material_mixture_indices

    def get_fuel_material_mixtures(self):
        """
        Return the list of MaterialMixture objects created by number_fuel_material_mixtures.
        Each object carries the unique name, index, Composition, temperature, and depletable flag.
        """
        if not hasattr(self, 'fuel_material_mixtures'):
            raise RuntimeError("Fuel material mixtures have not been numbered yet. Call number_fuel_material_mixtures first.")
        return self.fuel_material_mixtures

    def enforce_material_mixture_indices_from_tdt(self, tdt_indices_dict):
        """
        Update material mixture indices in the assembly model so they match the
        indices assigned by glow/SALOME in the TDT file.

        In the glow workflow, SALOME internally re-numbers material mixtures with
        no predictable logic.  The TDT .dat file records the actual
        ``unique_material_mixture_name → index`` mapping.  This method takes that
        mapping (typically obtained from ``read_material_mixture_indices_from_tdt_file``)
        and propagates it to:

        1. ``self.material_mixtures_dict``
        2. ``self.fuel_material_mixture_indices``
        3. Every ``MaterialMixture`` object in ``self.fuel_material_mixtures``
        4. Every ``FuelPinModel`` in the lattice (``pin.fuel_material_mixture_indices``)

        Parameters
        ----------
        tdt_indices_dict : dict[str, int]
            Mapping of unique material mixture name → index as read from the TDT
            file.  Only entries whose names match existing fuel material mixture
            names in the assembly model are applied; extra entries (e.g. COOLANT,
            CLAD, MODERATOR, GAP, CHANNEL_BOX) are stored separately in
            ``self.non_fuel_material_mixture_indices`` for later use.

        Raises
        ------
        RuntimeError
            If ``number_fuel_material_mixtures_by_material`` has not been called.
        ValueError
            If a fuel material mixture name created by
            ``number_fuel_material_mixtures_by_material`` is not found in the TDT
            mapping.
        """
        if not hasattr(self, 'fuel_material_mixture_names') or self.fuel_material_mixture_names is None:
            raise RuntimeError(
                "Fuel material mixtures have not been numbered yet. "
                "Call number_fuel_material_mixtures_by_material() before enforcing TDT indices."
            )

        # Separate fuel vs non-fuel entries from the TDT mapping
        fuel_names_set = set(self.fuel_material_mixture_names)
        non_fuel = {}

        for tdt_name, tdt_index in tdt_indices_dict.items():
            if tdt_name not in fuel_names_set:
                non_fuel[tdt_name] = tdt_index

        self.non_fuel_material_mixture_indices = non_fuel

        # Validate that every fuel mixture name has a TDT counterpart
        missing = [name for name in self.fuel_material_mixture_names if name not in tdt_indices_dict]
        if missing:
            raise ValueError(
                f"The following fuel material mixture names were not found in the TDT mapping: {missing}. "
                f"Available TDT names: {list(tdt_indices_dict.keys())}"
            )

        # --- Update assembly-level structures ---
        for name in self.fuel_material_mixture_names:
            self.material_mixtures_dict[name] = tdt_indices_dict[name]

        self.fuel_material_mixture_indices = [
            self.material_mixtures_dict[name] for name in self.fuel_material_mixture_names
        ]

        # --- Update each MaterialMixture object ---
        for mix in self.fuel_material_mixtures:
            new_index = self.material_mixtures_dict[mix.unique_material_mixture_name]
            mix.material_mixture_index = new_index

        # --- Update every FuelPinModel in the lattice ---
        for row in self.lattice:
            for pin in row:
                if isinstance(pin, FuelPinModel) and hasattr(pin, 'fuel_material_mixture_names'):
                    pin.fuel_material_mixture_indices = [
                        self.material_mixtures_dict[zone_name]
                        for zone_name in pin.fuel_material_mixture_names
                    ]

        print(f"[enforce_tdt] Updated {len(self.fuel_material_mixture_names)} fuel mixture indices from TDT file.")
        if non_fuel:
            print(f"[enforce_tdt] Also stored {len(non_fuel)} non-fuel mixture indices: {non_fuel}")

    def count_number_of_pins(self):
        """
        count the number of pins in the assembly based on the lattice description, which can be used for example to define the number of material mixtures needed for a pin-wise numbering strategy.
        """
        num_pins = 0
        for row in self.lattice_description:
            for descriptor in row:
                if descriptor not in self.non_fuel_rod_ids: # for now, we consider that water rods do not need a material mixture assigned to them for self-shielding treatment in Dragon, but this can be updated later to allow for specific material mixtures for water rods if needed based on the descriptors in the lattice description of the assembly model.
                    num_pins += 1
        return num_pins
    
    def count_number_of_unique_fuel_materials(self):
        """
        count the number of unique fuel materials in the assembly based on the lattice description, which can be used for example to define the number of material mixtures needed for a material-wise numbering strategy.
        """
        fuel_materials = set()
        for row in self.lattice_description:
            for descriptor in row:
                if descriptor not in self.non_fuel_rod_ids: # for now, we consider that water rods do not have a fuel material assigned to them for self-shielding treatment in Dragon, but this can be updated later to allow for specific fuel materials for water rods if needed based on the descriptors in the lattice description of the assembly model.
                    fuel_materials.add(descriptor)
        return len(fuel_materials)
           
    def set_rod_ID_to_material_mapping(self, rod_ID_to_material_dict):
        """
        Set the mapping between rod IDs in the lattice description and material names for the fuel in the assembly, which can be used to assign material properties to the different pins in the assembly based on their rod ID in the lattice description.
        """
        self.rod_ID_to_material_dict = rod_ID_to_material_dict
        return

    def set_uniform_temperatures(self, fuel_temperature, gap_temperature, coolant_temperature, moderator_temperature, structural_temperature):
        """
        set uniform temperatures for the different materials in the assembly, which can be used for temperature-dependent self-shielding treatment in Dragon.
        """
        self.fuel_temperature = fuel_temperature
        self.gap_temperature = gap_temperature
        self.coolant_temperature = coolant_temperature
        self.moderator_temperature = moderator_temperature
        self.structural_temperature = structural_temperature
        return

    def update_lattice_description(self, new_lattice_description):
        """
        Update the lattice description of the assembly model, which can be used to modify the geometry of the assembly and the corresponding pin models in the lattice based on a new lattice description.
        """
        self.lattice_description = new_lattice_description
        self.analyze_lattice_description(build_pins=True) # re-analyze the lattice description to update the lattice data structure and the pin models based on the new lattice description


class FuelPinModel:
    """
    Class representing a pin in a cartesian assembly for DRAGON calculations.

    Minimal attributes:

    - fuel_material_name: name of the fuel material assigned to the pin (e.g. UOX16, 24UOX)
    - pitch: regular pitch of the pin in the lattice
    - radii: list of radii for concentric cylindrical regions (fuel, cladding, gap)
    - region names: list of names for the different regions (fuel, cladding, gap)
    - height: height of the pin
    - self_shielding_option: radial subdivision strategy.  When ``None``
      (default), the pin is created with a single fuel zone (awaiting
      a ``DragonCalculationScheme`` to apply the desired subdivision).
      Other options: ``"Santamarina"``, ``"automatic"``, ``"user_defined"``.

    Methods:

    - subdivide_into_radial_zones: subdivide the pin into radial zones for
      self-shielding treatment in Dragon.
    """
    def __init__(self, fuel_material_name, radii, height, isGd, self_shielding_option=None, options_dict=None):
        self.fuel_material_name = fuel_material_name
        self.technological_radii = radii # ordered fuel radius, gap radius, clad radius : test if gap radius is smaller or larger than fuel radius to define the order of the regions in the pin and the corresponding radii in the list, which can be used to automatically define the pin geometry based on the input radii and the self-shielding option selected for the pin.
        self.height = height
        self.isGd = isGd
        self.self_shielding_option = self_shielding_option

        if self_shielding_option is None:
            # Default: single fuel region (1-zone) – awaiting DragonCalculationScheme
            self.subdivide_into_radial_zones(num_radial_zones=1)
            self.self_shielding_option = "default"
        elif self_shielding_option == "Santamarina":
            self.subdivide_into_Santamarina_radii()
        elif self_shielding_option == "user_defined":
            if options_dict is None or "user_defined_radii" not in options_dict:
                raise ValueError("For user-defined self-shielding option, a list of user-defined radii must be provided in the options_dict with key 'user_defined_radii'.")
            self.subdivide_into_user_defined_radii(options_dict["user_defined_radii"])
        elif self_shielding_option == "automatic":
            if options_dict is None or "num_radial_zones" not in options_dict:
                raise ValueError("For automatic self-shielding option, the number of radial zones must be provided in the options_dict with key 'num_radial_zones'.")
            self.subdivide_into_radial_zones(options_dict["num_radial_zones"])
        else:
            raise ValueError(f"Invalid self_shielding_option '{self_shielding_option}'. Valid options are None, 'Santamarina', 'user_defined' and 'automatic'.")

        print(f"Created : Pin with fuel material {self.fuel_material_name} subdivided into radial zones with radii {self.radii} based on self-shielding option {self.self_shielding_option}.")


    def subdivide_into_Santamarina_radii(self):
        # Import here to avoid circular import issues
        from ..GeometryBuilder.helpers import computeSantamarinaradii
        
        fuel_radius = self.technological_radii[0]
        gap_radius = self.technological_radii[1]
        clad_radius = self.technological_radii[2]
        # subdivide the pin into radial zones for self-shielding treatment in Dragon based on the Santamarina radii definition
        self.radii = computeSantamarinaradii(fuel_radius, gap_radius, clad_radius, gadolinium=self.isGd)


    def subdivide_into_radial_zones(self, num_radial_zones = None):
        # subdivide the pin into a given number of radial zones for self-shielding treatment in Dragon based on an automatic subdivision of the fuel region
        # test if gap radius is smaller or larger than fuel radius to define the order of the regions in the pin and the corresponding radii in the list, which can be used to automatically define the pin geometry based on the input radii and the self-shielding option selected for the pin.
        fuel_radius = self.technological_radii[0]
        gap_radius = self.technological_radii[1]
        clad_radius = self.technological_radii[2]
        if gap_radius is not None and gap_radius < fuel_radius:
            # in case expansion gap is inner most region, add it as the first radius and then compute the fuel radii based on the remaining fuel volume after subtracting the gap volume
            # need to subdivide radial region fron gap radius to fuel radius into num_radial_zones zones with equal radial width for example, but other subdivision strategies could be implemented as well.
            fuel_region_width = fuel_radius - gap_radius
            zone_width = fuel_region_width / num_radial_zones
            self.radii = [gap_radius + (i+1)*zone_width for i in range(num_radial_zones)]
            if clad_radius is not None:
                self.radii.append(clad_radius)
        else:
            # if gap radius is larger than fuel radius, we can just subdivide the fuel region into num_radial_zones zones with equal radial width for example, but other subdivision strategies could be implemented as well, and then add the gap radius and clad radius as the last radii in the list if they are defined.
            zone_width = fuel_radius / num_radial_zones
            self.radii = [(i+1)*zone_width for i in range(num_radial_zones)]
            if gap_radius is not None:
                self.radii.append(gap_radius)
            if clad_radius is not None:
                self.radii.append(clad_radius)
    
    def subdivide_into_user_defined_radii(self, user_defined_radii):
        # subdivide the pin into radial zones for self-shielding treatment in Dragon based on user-defined radii
        self.radii = user_defined_radii


    def count_number_of_fuel_radial_self_shielding_zones(self):
        # identify if gap and clad radius are None
        gap_radius = self.technological_radii[1]
        clad_radius = self.technological_radii[2]
        number_of_fuel_radial_zones = len(self.radii)
        if gap_radius is not None:
            number_of_fuel_radial_zones -= 1
        if clad_radius is not None:
            number_of_fuel_radial_zones -= 1
        self.number_of_self_shielding_fuel_zones = number_of_fuel_radial_zones

    def set_position_in_lattice(self, x_index, y_index):
        """
        set fuel pincell position in the lattice based on x and y indices in the lattice description of the assembly model. 
        """
        self.x_index = x_index
        self.y_index = y_index

    def set_fuel_temperature(self, fuel_temperature):
        """
        set fuel temperature for the pin, which can be used for temperature-dependent self-shielding treatment in Dragon.
        """
        self.fuel_temperature = fuel_temperature
    
    def set_gap_temperature(self, gap_temperature):
        """
        set gap temperature for the pin.
        """
        self.gap_temperature = gap_temperature
    
    def set_clad_temperature(self, clad_temperature):
        """
        set cladding temperature for the pin, which can be used for temperature-dependent self-shielding treatment in Dragon.
        """
        self.clad_temperature = clad_temperature

    def set_coolant_temperature(self, coolant_temperature):
        """
        set coolant temperature for the pin.
        """
        self.coolant_temperature = coolant_temperature

    def set_rod_ID(self, rod_ID):
        """
        set the rod ID for the pin based on the descriptor in the lattice description of the assembly model, which can be used to assign material properties to the pin based on its rod ID in the lattice description.
        """
        self.rod_ID = rod_ID

    def set_center(self, center_x, center_y):
        """
        Set the center coordinates (x, y) of the pin in the assembly coordinate system.
        This is useful for lattice analysis and spatial queries.
        """
        self.center_x = center_x
        self.center_y = center_y
        self.center = (center_x, center_y)


class CircularWaterRodModel:
    """
    Class representing a circular water rod in a cartesian assembly for DRAGON calculations.

    Minimal attributes:

    - bounding box side length: side length of the square cell containing the water rod.
    - inner radius: inner radius of the circular water rod.
    - outer radius: outer radius of the circular water rod.
    - center: center coordinates of the circular water rod in the lattice.

    Methods:

    - set_moderator_temperature: set the moderator temperature for the water rod.
    - set_structural_temperature: set the structural temperature for the water rod.
    """
    def __init__(self, bounding_box_side_length, inner_radius, outer_radius, center, rod_ID = "WROD"):
        self.bounding_box_side_length = bounding_box_side_length
        self.inner_radius = inner_radius
        self.outer_radius = outer_radius
        self.center = center
        self.rod_ID = rod_ID


    def set_moderator_temperature(self, moderator_temperature):
        """
        set moderator temperature for the water rod, which can be used for temperature-dependent self-shielding treatment in Dragon.
        """
        self.moderator_temperature = moderator_temperature

    def set_structural_temperature(self, structural_temperature):
        """
        set structural temperature for the water rod, which can be used for temperature-dependent self-shielding treatment in Dragon.
        """
        self.structural_temperature = structural_temperature

    def set_position_in_lattice(self, x_index, y_index):
        """
        set water rod position in the lattice based on x and y indices in the lattice description of the assembly model. 
        """
        self.x_index = x_index
        self.y_index = y_index

    def set_materials(self, moderator_material_name, cladding_material_name, coolant_material_name):
        """
        set the material names for the moderator, cladding and coolant regions of the water rod
        """
        self.moderator_material_name = moderator_material_name
        self.cladding_material_name = cladding_material_name
        self.coolant_material_name = coolant_material_name


class SquareWaterRodModel:
    """
    Class representing a square water rod in a cartesian assembly for DRAGON calculations.

    Minimal attributes:

    - bounding box side length: side length of the square water rod.
    - moderator box outer side: outer side length of the moderator box.
    - moderator box inner side: inner side length of the moderator box.
    - center: center coordinates of the square water rod in the lattice.

    Methods:

    - set_moderator_temperature: set the moderator temperature for the water rod.
    - set_structural_temperature: set the structural temperature for the water rod.
    """
    def __init__(self, bounding_box_side_length, moderator_box_outer_side, moderator_box_inner_side, center, rod_ID):
        self.bounding_box_side_length = bounding_box_side_length
        self.moderator_box_outer_side = moderator_box_outer_side
        self.moderator_box_inner_side = moderator_box_inner_side
        self.center = center
        self.rod_ID = rod_ID


    def set_moderator_temperature(self, moderator_temperature):
        """
        set moderator temperature for the water rod, which can be used for temperature-dependent self-shielding treatment in Dragon.
        """
        self.moderator_temperature = moderator_temperature

    def set_structural_temperature(self, structural_temperature):
        """
        set structural temperature for the water rod, which can be used for temperature-dependent self-shielding treatment in Dragon.
        """
        self.structural_temperature = structural_temperature

    def set_position_in_lattice(self, x_index, y_index):
        """
        set water rod position in the lattice based on x and y indices in the lattice description of the assembly model. 
        """
        self.x_index = x_index
        self.y_index = y_index
        
    def set_materials(self, moderator_material_name, cladding_material_name, coolant_material_name):
        """
        set the material names for the moderator, cladding and coolant regions of the water rod
        """
        self.moderator_material_name = moderator_material_name
        self.cladding_material_name = cladding_material_name
        self.coolant_material_name = coolant_material_name



        
class DummyPinModel:
    """
    Class representing a dummy pin in a cartesian assembly for DRAGON calculations.

    This class can be used to represent regions in the lattice that are not fuel pins,
    such as guide tubes, instrumentation tubes, or other structural components that do
    not require material mixture assignment for self-shielding treatment in Dragon.

    Minimal attributes:

    - descriptor: descriptor of the region in the lattice description
      (e.g. GT for guide tube, IT for instrumentation tube)

    Methods:

    - set_position_in_lattice: set the position of the dummy pin in the lattice
      based on x and y indices.
    """
    def __init__(self, descriptor):
        self.rod_ID = descriptor
        

    def set_position_in_lattice(self, x_index, y_index):
        """
        set dummy pin position in the lattice based on x and y indices in the lattice description of the assembly model. 
        """
        self.x_index = x_index
        self.y_index = y_index

    def set_center(self, center_x, center_y):
        """
        Set the center coordinates (x, y) of the dummy pin in the assembly coordinate system.
        This is useful for lattice analysis and spatial queries.
        """
        self.center_x = center_x
        self.center_y = center_y
        self.center = (center_x, center_y)